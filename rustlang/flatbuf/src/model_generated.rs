// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod model {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    pub enum ModuleOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Module<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Module<'a> {
        type Inner = Module<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Module<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Module { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ModuleArgs<'args>,
        ) -> flatbuffers::WIPOffset<Module<'bldr>> {
            let mut builder = ModuleBuilder::new(_fbb);
            builder.add_id(args.id);
            if let Some(x) = args.sequence {
                builder.add_sequence(x);
            }
            if let Some(x) = args.url {
                builder.add_url(x);
            }
            if let Some(x) = args.publishedVersion {
                builder.add_publishedVersion(x);
            }
            if let Some(x) = args.contributors {
                builder.add_contributors(x);
            }
            if let Some(x) = args.maintainer {
                builder.add_maintainer(x);
            }
            if let Some(x) = args.license {
                builder.add_license(x);
            }
            if let Some(x) = args.description {
                builder.add_description(x);
            }
            if let Some(x) = args.displayName {
                builder.add_displayName(x);
            }
            if let Some(x) = args.latestVersion {
                builder.add_latestVersion(x);
            }
            if let Some(x) = args.state {
                builder.add_state(x);
            }
            if let Some(x) = args.author {
                builder.add_author(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.summary {
                builder.add_summary(x);
            }
            if let Some(x) = args.website {
                builder.add_website(x);
            }
            builder.add_toBuy(args.toBuy);
            builder.add_autoInstall(args.autoInstall);
            builder.add_web(args.web);
            builder.add_demo(args.demo);
            builder.add_application(args.application);
            builder.finish()
        }

        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_WEBSITE: flatbuffers::VOffsetT = 6;
        pub const VT_SUMMARY: flatbuffers::VOffsetT = 8;
        pub const VT_NAME: flatbuffers::VOffsetT = 10;
        pub const VT_AUTHOR: flatbuffers::VOffsetT = 12;
        pub const VT_STATE: flatbuffers::VOffsetT = 14;
        pub const VT_LATESTVERSION: flatbuffers::VOffsetT = 16;
        pub const VT_DISPLAYNAME: flatbuffers::VOffsetT = 18;
        pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 20;
        pub const VT_APPLICATION: flatbuffers::VOffsetT = 22;
        pub const VT_DEMO: flatbuffers::VOffsetT = 24;
        pub const VT_WEB: flatbuffers::VOffsetT = 26;
        pub const VT_LICENSE: flatbuffers::VOffsetT = 28;
        pub const VT_AUTOINSTALL: flatbuffers::VOffsetT = 30;
        pub const VT_TOBUY: flatbuffers::VOffsetT = 32;
        pub const VT_MAINTAINER: flatbuffers::VOffsetT = 34;
        pub const VT_CONTRIBUTORS: flatbuffers::VOffsetT = 36;
        pub const VT_PUBLISHEDVERSION: flatbuffers::VOffsetT = 38;
        pub const VT_URL: flatbuffers::VOffsetT = 40;
        pub const VT_SEQUENCE: flatbuffers::VOffsetT = 42;

        #[inline]
        pub fn id(&self) -> u64 {
            self._tab.get::<u64>(Module::VT_ID, Some(0)).unwrap()
        }
        #[inline]
        pub fn website(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_WEBSITE, None)
        }
        #[inline]
        pub fn summary(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_SUMMARY, None)
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_NAME, None)
        }
        #[inline]
        pub fn author(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_AUTHOR, None)
        }
        #[inline]
        pub fn state(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_STATE, None)
        }
        #[inline]
        pub fn latestVersion(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_LATESTVERSION, None)
        }
        #[inline]
        pub fn displayName(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_DISPLAYNAME, None)
        }
        #[inline]
        pub fn description(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_DESCRIPTION, None)
        }
        #[inline]
        pub fn application(&self) -> bool {
            self._tab
                .get::<bool>(Module::VT_APPLICATION, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn demo(&self) -> bool {
            self._tab.get::<bool>(Module::VT_DEMO, Some(false)).unwrap()
        }
        #[inline]
        pub fn web(&self) -> bool {
            self._tab.get::<bool>(Module::VT_WEB, Some(false)).unwrap()
        }
        #[inline]
        pub fn license(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_LICENSE, None)
        }
        #[inline]
        pub fn autoInstall(&self) -> bool {
            self._tab
                .get::<bool>(Module::VT_AUTOINSTALL, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn toBuy(&self) -> bool {
            self._tab
                .get::<bool>(Module::VT_TOBUY, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn maintainer(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_MAINTAINER, None)
        }
        #[inline]
        pub fn contributors(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_CONTRIBUTORS, None)
        }
        #[inline]
        pub fn publishedVersion(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_PUBLISHEDVERSION, None)
        }
        #[inline]
        pub fn url(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_URL, None)
        }
        #[inline]
        pub fn sequence(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Module::VT_SEQUENCE, None)
        }
    }

    pub struct ModuleArgs<'a> {
        pub id: u64,
        pub website: Option<flatbuffers::WIPOffset<&'a str>>,
        pub summary: Option<flatbuffers::WIPOffset<&'a str>>,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub author: Option<flatbuffers::WIPOffset<&'a str>>,
        pub state: Option<flatbuffers::WIPOffset<&'a str>>,
        pub latestVersion: Option<flatbuffers::WIPOffset<&'a str>>,
        pub displayName: Option<flatbuffers::WIPOffset<&'a str>>,
        pub description: Option<flatbuffers::WIPOffset<&'a str>>,
        pub application: bool,
        pub demo: bool,
        pub web: bool,
        pub license: Option<flatbuffers::WIPOffset<&'a str>>,
        pub autoInstall: bool,
        pub toBuy: bool,
        pub maintainer: Option<flatbuffers::WIPOffset<&'a str>>,
        pub contributors: Option<flatbuffers::WIPOffset<&'a str>>,
        pub publishedVersion: Option<flatbuffers::WIPOffset<&'a str>>,
        pub url: Option<flatbuffers::WIPOffset<&'a str>>,
        pub sequence: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ModuleArgs<'a> {
        #[inline]
        fn default() -> Self {
            ModuleArgs {
                id: 0,
                website: None,
                summary: None,
                name: None,
                author: None,
                state: None,
                latestVersion: None,
                displayName: None,
                description: None,
                application: false,
                demo: false,
                web: false,
                license: None,
                autoInstall: false,
                toBuy: false,
                maintainer: None,
                contributors: None,
                publishedVersion: None,
                url: None,
                sequence: None,
            }
        }
    }
    pub struct ModuleBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ModuleBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u64) {
            self.fbb_.push_slot::<u64>(Module::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_website(&mut self, website: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Module::VT_WEBSITE, website);
        }
        #[inline]
        pub fn add_summary(&mut self, summary: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Module::VT_SUMMARY, summary);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Module::VT_NAME, name);
        }
        #[inline]
        pub fn add_author(&mut self, author: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Module::VT_AUTHOR, author);
        }
        #[inline]
        pub fn add_state(&mut self, state: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Module::VT_STATE, state);
        }
        #[inline]
        pub fn add_latestVersion(&mut self, latestVersion: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Module::VT_LATESTVERSION,
                latestVersion,
            );
        }
        #[inline]
        pub fn add_displayName(&mut self, displayName: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Module::VT_DISPLAYNAME, displayName);
        }
        #[inline]
        pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Module::VT_DESCRIPTION, description);
        }
        #[inline]
        pub fn add_application(&mut self, application: bool) {
            self.fbb_
                .push_slot::<bool>(Module::VT_APPLICATION, application, false);
        }
        #[inline]
        pub fn add_demo(&mut self, demo: bool) {
            self.fbb_.push_slot::<bool>(Module::VT_DEMO, demo, false);
        }
        #[inline]
        pub fn add_web(&mut self, web: bool) {
            self.fbb_.push_slot::<bool>(Module::VT_WEB, web, false);
        }
        #[inline]
        pub fn add_license(&mut self, license: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Module::VT_LICENSE, license);
        }
        #[inline]
        pub fn add_autoInstall(&mut self, autoInstall: bool) {
            self.fbb_
                .push_slot::<bool>(Module::VT_AUTOINSTALL, autoInstall, false);
        }
        #[inline]
        pub fn add_toBuy(&mut self, toBuy: bool) {
            self.fbb_.push_slot::<bool>(Module::VT_TOBUY, toBuy, false);
        }
        #[inline]
        pub fn add_maintainer(&mut self, maintainer: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Module::VT_MAINTAINER, maintainer);
        }
        #[inline]
        pub fn add_contributors(&mut self, contributors: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Module::VT_CONTRIBUTORS,
                contributors,
            );
        }
        #[inline]
        pub fn add_publishedVersion(&mut self, publishedVersion: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Module::VT_PUBLISHEDVERSION,
                publishedVersion,
            );
        }
        #[inline]
        pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Module::VT_URL, url);
        }
        #[inline]
        pub fn add_sequence(&mut self, sequence: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Module::VT_SEQUENCE, sequence);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModuleBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ModuleBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Module<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ModelOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Model<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Model<'a> {
        type Inner = Model<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Model<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Model { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ModelArgs<'args>,
        ) -> flatbuffers::WIPOffset<Model<'bldr>> {
            let mut builder = ModelBuilder::new(_fbb);
            builder.add_id(args.id);
            if let Some(x) = args.module {
                builder.add_module(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;
        pub const VT_MODULE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn id(&self) -> u64 {
            self._tab.get::<u64>(Model::VT_ID, Some(0)).unwrap()
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Model::VT_NAME, None)
        }
        #[inline]
        pub fn module(&self) -> Option<Module<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Module<'a>>>(Model::VT_MODULE, None)
        }
    }

    pub struct ModelArgs<'a> {
        pub id: u64,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub module: Option<flatbuffers::WIPOffset<Module<'a>>>,
    }
    impl<'a> Default for ModelArgs<'a> {
        #[inline]
        fn default() -> Self {
            ModelArgs {
                id: 0,
                name: None,
                module: None,
            }
        }
    }
    pub struct ModelBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ModelBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u64) {
            self.fbb_.push_slot::<u64>(Model::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_NAME, name);
        }
        #[inline]
        pub fn add_module(&mut self, module: flatbuffers::WIPOffset<Module<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Module>>(Model::VT_MODULE, module);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModelBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ModelBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Model<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }
} // pub mod model
